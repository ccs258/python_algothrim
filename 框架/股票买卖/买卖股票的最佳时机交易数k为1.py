"""
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

 

示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2:

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
"""


# i = n
# k = 1
# rest = 0, 1;
# 0表示当前这天没有股票，可能是前一天没有；也可能是今天卖出去了；
# 1表示当前这天有股票，可能是前一天有；也可能是今天买的；
# 对应的上述的0,1状态的利润：
# rest为0的时候，为max(dp[i-1][k][0],dp[i][k][1]+price)
# rest为1的时候，为max(dp[i-1][k][1],dp[i][k][0]-price)


# 初始状态为：
# dp[0][k][0] = 0 ,dp[0][k][1] = -inf


# 代码如下

def solution_err(prices):
    """
    只能交易1次，即买一次卖一次 称为一个完整的交易
    """
    n = len(prices)
    dp = [[0, 0] for i in range(n)]  # 其中row代表天数，col代表每天可能的两种股票持有状态，0代表没有股票，1代表有股票
    dp[0][0] = -100000
    dp[0][1] = 0
    i = 1
    while (i < n):
        dp[i][0] = max(dp[i - 1][0], dp[i][1] + prices[i - 1])
        # 此处理解有误，当前这天的状态以及前一天的盈利决定最终的盈利，当前的状态决定是否需要加入price考虑；
        # 如果为0，且为卖则考虑，否则不考虑；如果为1，且为买加入考虑，否则不考虑；
        dp[i][1] = max(dp[i - 1][1], -prices[i])  # dp[i][1] = max(dp[i-1][1],dp[i][0]-prices[i-1]),要么是今天才买的，前面为没有
        i = i + 1
    return dp[n - 1][0]


def solution_final(prices):
    n = len(prices)
    dp = [[0, 0] for i in range(n)]  # 其中row代表天数，col代表每天可能的两种股票持有状态，0代表没有股票，1代表有股票
    # dp[0][0] = -100000  #错误，记录状态的可以从0，开始，对应的是初始盈利状态；
    # dp[0][1] = 0
    i = 0  # i从0开始；
    while (i < n):
        if i - 1 == -1:
            dp[i][0] = 0  # 初始状态没买，盈利为0
            dp[i][1] = -prices[i]  # 初始状态买了，盈利为支出的价格
            i = i + 1  # 这里面需要有状态更新
            continue
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])  #先有买，才有卖，因此有历史盈利项
        # 正解：当前这天没买，要么盈利为上一天的持有股票且今天没买状态的盈利，即没有买卖项，只依赖于上一天；要么盈利为当天的卖了的盈利（即上一天持有股票且今天卖了的盈利：即为上一天持有股票的盈利-当前这天收入的价格）
        dp[i][1] = max(dp[i - 1][1], -prices[i])  #买只会发生在最开始，并且只会发生一次，因此没有历史盈利项；这个地方是指第一次买，之前的不会有盈利项
        i = i + 1
    return dp[n - 1][0]


if __name__ == '__main__':
    # prices = [7, 1, 5, 3, 6, 4]
    prices = [7,6,4,3,1]
    rst = solution_final(prices)
    print("rst is ", rst)
