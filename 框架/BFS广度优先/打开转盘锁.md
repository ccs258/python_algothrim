#题目描述
你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。
每个拨轮可以自由旋转：例如把 '9' 变为  '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。
* 每次旋转都只能旋转一个拨轮的一位数字。

锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。

列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。

字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。



#自我理解
密码锁自我理解：全盘，0和9相邻，0也和1相邻；9和1相邻，也和8相邻，每次只能转动4个圆盘之一，且每次转动只能转一格；
死亡密码不能转动，否则被锁定；从前往后；或者从后往前，按一个位一个位寻找，直到找到合适的目标值为止；

通过初始化值，一个位一个位与目标比较，看是往顺时针转还是往逆时针转，每次都这样

#怎么转化成BFS
##初始值
##终止条件
##队列元素添加或移除
#参考





#思路
    队列：包含下列扩散节点
    扩散节点：将每一轮的所有可能（可能转4个转盘，中的其中一个数字），表示为扩散节点；因为其实我最终看的结果，是看整体4个转盘的所有一步移动后的可能
    标记节点：
    判断条件：遇到死亡节点，就继续，循环找下一个邻近节点；死亡节点可以和标记节点作为一个变量使用，把当前遍历的节点作为更新死亡节点
    终止条件：遇到目标值之后就返回；或者队列为空之后就退出，未找到结果；
    


   
                
        
 
https://blog.csdn.net/yfy1127yfy/article/details/103009447
