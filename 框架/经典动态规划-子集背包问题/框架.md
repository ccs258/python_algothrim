#思路
算法的函数签名如下：
// 输入一个集合，返回是否能够分割成和相等的两个子集
bool canPartition(vector<int>& nums);
对于这个问题，看起来和背包没有任何关系，为什么说它是背包问题呢？
首先回忆一下背包问题大致的描述是什么：
给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？
那么对于这个问题，我们可以先对集合求和，得出 sum，把问题转化为背包问题：
给一个可装载重量为 sum / 2 的背包和 N 个物品，每个物品的重量为 nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满？
你看，这就是背包问题的模型，甚至比我们之前的经典背包问题还要简单一些，下面我们就直接转换成背包问题，开始套前文讲过的背包问题框架即可。__


#解法分析
第一步要明确两点，「状态」和「选择」。
这个前文 经典动态规划：背包问题 已经详细解释过了，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。


#我的解法
三个变量：已知列表，遍历索引，结果列表

初始状态：
如果结果列表求和等于目标值，则返回结果；
如果遍历索引>列表长度，返回False;

状态：当前取的值索引，结果列表
选择：
如果当前值+上一次结果列表之和 小于等于目标值，则更新索引和将当前值添加到结果列表进行结果列表更新；
如果当前值+上一次结果列表之和 大于目标值，则更新索引，结果列表不做更新；
