#框架
    def dp(K,N):
        for 1 <= i  <= N:
            //最坏情况下最少扔鸡蛋次数
            res = min(res,max(dp[K-1,i-1], //碎
                            dp[K,N-i]) //没碎
                        +1  //在第i楼扔了一次
                    )      
        return res      
    
#思路详解
       对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。
       
       「状态」很明显，就是当前拥有的鸡蛋数K和需要测试的楼层数N。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。
       
       「选择」其实就是去选择哪层楼扔鸡蛋。回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。
       
       现在明确了「状态」和「选择」，动态规划的基本思路就形成了：肯定是个二维的dp数组或者带有两个状态参数的dp函数来表示状态转移；外加一个 for 循环来遍历所有选择，择最优的选择更新结果 ：
       
       当前状态为 (K 个鸡蛋，N 层楼)
       返回这个状态下的最优结果
       def dp(K, N):
           int res
           for 1 <= i <= N:
               res = min(res, 这次在第 i 层楼扔鸡蛋)
           return res
       
       这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。
       
       我们在第i层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。注意，这时候状态转移就来了：
       
       如果鸡蛋碎了，那么鸡蛋的个数K应该减一，搜索的楼层区间应该从[1..N]变为[1..i-1]共i-1层楼；
       
       如果鸡蛋没碎，那么鸡蛋的个数K不变，搜索的楼层区间应该从 [1..N]变为[i+1..N]共N-i层楼。
#鸡蛋个数不限制的话，可用二分法；如果限制的话，只能用全搜索法
       实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，现在给你了鸡蛋个数的限制 K，直接使用二分思路就不行了。
       比如说只给你 1 个鸡蛋，7 层楼，你敢用二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，但如果碎了你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层 F 了。这种情况下只能用线性扫描的方法，算法返回结果应该是 7。
       有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？
       很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。
       如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次​。
       最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。
#总结点
    （注意其他非初始化项的迭代项的方向，这里i-1，表示向下；而N-i表示向上遍历,这个地方方向只会影响为遍历的层数，于实际楼层的索引无关，至于多少层有关；例如1-3层，共3层；与5-8层，共3层处理方式是一样的）
