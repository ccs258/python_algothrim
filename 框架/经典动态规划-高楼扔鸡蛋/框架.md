#框架
    def dp(K,N):
        for 1 <= i  <= N:
            //最坏情况下最少扔鸡蛋次数
            res = min(res,max(dp[K-1,i-1], //碎
                            dp[K,N-i]) //没碎
                        +1  //在第i楼扔了一次
                    )      
        return res      
    
#思路详解
       对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。
       
       「状态」很明显，就是当前拥有的鸡蛋数K和需要测试的楼层数N。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。
       
       「选择」其实就是去选择哪层楼扔鸡蛋。回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。
       
       现在明确了「状态」和「选择」，动态规划的基本思路就形成了：肯定是个二维的dp数组或者带有两个状态参数的dp函数来表示状态转移；外加一个 for 循环来遍历所有选择，择最优的选择更新结果 ：
       
       当前状态为 (K 个鸡蛋，N 层楼)
       返回这个状态下的最优结果
       def dp(K, N):
           int res
           for 1 <= i <= N:
               res = min(res, 这次在第 i 层楼扔鸡蛋)
           return res
       
       这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。
       
       我们在第i层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。注意，这时候状态转移就来了：
       
       如果鸡蛋碎了，那么鸡蛋的个数K应该减一，搜索的楼层区间应该从[1..N]变为[1..i-1]共i-1层楼；
       
       如果鸡蛋没碎，那么鸡蛋的个数K不变，搜索的楼层区间应该从 [1..N]变为[i+1..N]共N-i层楼。
       
#总结点
    （注意其他非初始化项的迭代项的方向，这里i-1，表示向下；而N-i表示向上遍历,这个地方方向只会影响为遍历的层数，于实际楼层的索引无关，至于多少层有关；例如1-3层，共3层；与5-8层，共3层处理方式是一样的）
