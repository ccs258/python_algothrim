# -*- coding: utf-8 -*-
# @Time : 2020/6/19 16:14
# @Author : ccs
"""
解决方案
方法一：双指针
为什么要用双指针？
一个指针用来遍历？诀窍，
步骤1：

########################~思考过程~#############################
不等于val则保存结果~~~~~~~~~反着来考虑，不是等于；等于太复杂了，可能还有连续等于，如果是不等于，满足就存储结果，不满足就跳过当前元素，继续找下一个不等于的；
相反，如果刚开始按照等于考虑，如果连续等于，则令覆盖，下一个仍相等需要调用递归，再从头遍历，很没有必要；
##############################################################

用i代表数组保存结果的数组长度，并且从0到i存储结果；
用j表示整个数组的遍历；

上述步骤1中，存在一个潜在的约束：i必小于等于j，这样就不用了担心,修改i会改变整个元素的值；

核心思想：我只关注我保存结果的i,及在这个i的索引处存值；不用担心i>j,导致结果变化；


比如[3,2,2,3]，移除3的话，如果用a[i]= a[i+1]这样就编程a[2,2,2,3]这样是不对的；

上面双指针是不等于，


"""