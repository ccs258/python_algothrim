# -*- coding: utf-8 -*-
# @Time : 2020/6/22 9:11
# @Author : ccs

"""
给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
说明:
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]

"""
from typing import List

class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        self.merge_1([],nums1[:m],nums2[:n])

    def merge_1(self, rst,nums1,nums2):
        if not nums1:
            rst.extend(nums2)
            print("rst 1",rst)
            return rst
        if not nums2:
            rst.extend(nums1)
            print("rst 2",rst)
            return rst
        if nums1[0] >= nums2[0]:
            rst.append(nums2[0])
            return self.merge(rst,nums1,nums2[1:])
        elif nums1[0] < nums2[0]:
            rst.append(nums1[0])
            return self.merge(rst, nums1[1:], nums2)

    def merge_2(self,rst,nums1,m,nums2,n):
        rst = [0]*(m+n-1)
        p1 = 0
        p2 = 0
        p = 0
        while p1 < m-1 and p2 < n-1:
            if nums1[p1] < nums2[p2]:
                rst[p] = nums1[p1]
                p1 = p1 + 1
            else:
                rst[p] = nums2[p2]
                p2 = p2 + 1
            p = p + 1
        if p1 < m - 1 :
            rst[p1+p2+1:] = nums1[p:]
        if p2 < n - 1:
            rst[p1+p2+1:] = nums1[p:]

"""
总结：
对比自己写的递归；为什么写递归；
首先声明三个变量，一个存结果，一个存nums1,一个存nums2;但由于题目要求不要返回任何值，因此，结果只能保存在输入的列表中，于是令nums1_copy = nums1[:],nums1=[:];

递归的作用：
首先对输入两个元素的第一个值进行相比，返回结果表；
然后，以后的每次比较，都是结果表里面的最后一个元素，与当前的输入的两个表里面的结果进行对比，看大小，选择进入结果表，下一步仍然如此；只是相应的位置+1；
于是可以出了考虑，递归；

递归的缺点：每次输入占空间；每次比较只比较第一个元素，但输入是输出整个列表数组

官方是用指针+while循环来实现的：

还可以用指针的方式实现，可以用三个指针；因为递归的输入变化可以由指针达到；输出变量的赋值也可以由指针定位。


递归和循环的比较：

递归（recursion）：在函数内调用自身，将复杂情况逐步转化成基本情况。有网友说：递归就是包子馅包子，它的极限就是馒头。仔细想想，哈哈，就是这么个理儿。递归分为线性递归和尾递归。

举个栗子，已知f(2)=3,f(n)=f(n-1)+n,求f(5)？

答：f(5)=f(4)+5=f(3)+4+5=f(2)+3+4+5=15

怎么样，当发现自己在高中时就利用过递归思想，有没有一种原来自己从小就这么厉害了的自豪感。

这里的f(2)就是基线条件，这似乎就是人们所说的“出口”。基线条件就是函数没必要再循环下去了。
循环（loop）：在满足条件的情况下，重复执行同一段代码，比如while语句。

这个简单，不再赘述。

综上。看到一个网友这样描述两者：递归就像小明要去楼顶取东西，从一楼开始爬，看，不是的，继续爬，每层楼梯看上去都一样，但1到2,2到3的楼梯是两个楼梯，等到了楼顶，取到东西，不能直接跳楼跳下来，还得从楼顶一层层退回来。

而while循环，就像驴子拉磨，无论跑多少次，都是在原地。变化的只是磨盘里的磨的东西，而不是驴每圈所在的不同位置。

优缺点比较

递归

优点：代码更简洁清晰，可读性更好。

缺点：由于递归需要系统堆栈，所以空间消耗要比非递归代码要大很多。而且，如果递归深度太大，可能系统撑不住。

循环

优点：速度快，结构简单

缺点：并不能解决所有的问题

使用范围比较

循环能干的事，递归都能干；递归能干的事，循环不一定能干。如果使用循环并不困难的话，最好使用循环。

附录

循环和递归在上面已说，在此不再赘述。下面说说迭代和遍历。

迭代（iterate）：在数学中：在多次循环中逐步接近结果。

           在编程中：按顺序访问一个列表中的每一项。适用于线性结构，如数组和队列

遍历（traversal）：按规则访问结构中的每一项，且每项只访问一次。适用于非线性结构，如树，图。

小结

（1）至于两者的转换，又是另一个问题了。

（2）对递归的真正理解，还需在真正使用中体会。

（3）感谢广大网友给的参考。
————————————————
版权声明：本文为CSDN博主「Beyond_2016」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Beyond_2016/article/details/81283054

"""


if __name__ == '__main__':
    so = Solution()
    nums1 = [12]
    nums2 = [2,5,6]
    rst = []

    so.merge_1(rst,nums1,nums2)

